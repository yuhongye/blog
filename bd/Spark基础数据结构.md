## core.util.collection阅读

#### AppendOnlyMap[K, V]

使用开放地址法来实现只能追加的Map结构，其中key和value连续存储占用2个slot。bucket的大小是2^n，load factory是0.7。开放地址法使用了Quadratic_probing，假设某个元素计算的slot pos: 0

1. 第一次没发现， pos = pos + 1 ==> 1
2. 第二次没发现,    pos = pos + 2 ==> 3
3. 第三次没发现,    pos = pos + 3 ==> 6
4. 第四次没发现,    pos = pos + 4 ==> 10

#### CompactBuffer[T]

使用了两个变量`elment0`和`element1`来保存value个数小于等于2的情况，省去了创建底层数据带来的开销；如果value个数超过2个了，则仍然创建底层数组。这有一点启示：在特定的场景下可以创建专用数据结构来达到性能最优。

#### SizeTracker 采样预估当前对象的大小

由于预估对象的大小是一个较耗时的操作，因此不能每次改变都重新预估一次对象大小，而是使用采样的方式。采样的频率使用指数增长，比如初始设置的X， 第2次1.1X次更新后采样，第3次1.1 * 1.1 * X更新后采样。

采样算法：

1. T1时刻对象预估大小 s1, 更新次数u1
2. T2时刻对象预估大小 s2, 更新次数u2
3. 则每次更新的平均大小 avg = (s2 - s1) / (u2 - u1)
4. 在T3时刻更新次数为u3，此时预估的大小：s1 + (u3 - u2) * avg

