### InsertSort
insert sort思想：在一段序列中，前k个位置已经有序，对于第k+1处的值，从k处开始往前扫描，找到合适的位置插入。有一段比较简洁的代码实现:

```java
void sort(int[] array) {
    for (int i = 1; i < array.length; i++) {
        int tmp = array[i];
        int p = i;
        for (; p > 0 && array[p - 1] > tmp; p--) {
            array[p] = array[p-1];
        }
        array[p] = tmp;
    }
}
```
__时间分析__: o(n^2)

# 1. 快速排序
平均运行时间O(nlogn)，实践中已知最快的排序算法：__非常精练和高度优化的内部循环__。任何微小的改动都可能导致实践中巨大的性能损失。

由于递归的原因，对于小数组不如插入排序高效。

### 遇到等于pivoted的元素时怎么办
在一次划分中，如果左右两个子序列大致相同，那么算法是最高效的。由此可以得到一个原则：在左右两端的指针l, h，如果遇到相同的元素，它们应该采取一致的策略，否则就会偏向一方，导致某一个序列明显变长。考虑一串所有元素都相同的序列，如果遇到相等的元素不交换，则每次划分会导致一个序列的长度为1，另一个为N-1, 这是最坏的情况。

__方法__: 如果遇到等于pivoted的元素，就交换。虽然会带来不必要的交换，但是我们避免了最坏的情况。

### 枢纽元的选取： 三数取中值法
对最左端Left, 中间位置Middle, 最右端Right 三个位置进行排序，A[Middle]作为pivoted，同时swap(A[Middle], A[Right-1])。这种方法会带来三个好处：

1. 排序后，Left, Right都处在正确的位置，在划分时不需要再动
2. 由于`A[Left] <= pivoted`，可以当做h的警戒标记, 避免了越界的判断；
3. 由于`A[Right-1] == pivoted`, v它可以作为l的标记。
```java
int media3(int[] A, int left, int right) {
    // 小数组使用插入排序，这里默认(right - left) >= 2
    int middle = left + (right - left) / 2;
    if (A[left] > A[middle]) {
        swap(A, left, middle);
    }
    if (A[middle] > A[right]) {
        swap(A, middle, right);
    }
    if (A[left] > A[middle]) {
        swap(A, left, middle);
    }
    // 现在left, middle, right是有序的

    // 把pivoted放到right - 1处
    swap(A, middle, right - 1);
    return A[right - 1];
}
````

### 经典快排代码
```java
int CUT_THRESHOLD = 3;
void qsort(int[] A, int left, int right) {
    if (left + CUT_THRESHOLD > right) {
        insertsort(...);
        return;
    }

    int pivot = median3(A, left, right);
    int l = left;
    int h = right - 1;

   // 重要的是: 每次循环都会使i和j至少前进一个位置
    while (true) {
        while (A[++l] < pivot);
        while (A[--h] > pivot);
        if (l < h) {
            swap(A, l, h);
        } else {
          break;
        }
    }
    
    /**
     * 把pivot放到正确的位置：l处
     *  - l指向一个>=pivot的元素
     *  - h指向一个<=pivot的元素
     */
     swap(A, l, right - 1);
     // 交换完后，l就是枢纽元争取的位置
     qsort(A, left, l - 1);
     qsort(A, l + 1, right);
}
```

# 2. 工程上实现最快的快排
这一节的内容基于发表于1993年的论文《Engineering a Sort Function》，基于当时的硬件情况，设计出了在工程上最快的快排实现。Jdk6中的快排就是根据这篇论文实现的。
### 再谈枢纽元的选择
在第一节中我们实现了三数取中值作为枢纽元，这里我们实现一个纯比较版本.
```java
/**
 * 通过最多三次比较，得到三数的中值所在位置
 * @param a, b, c 表示待比较三个数的下标
 * @return 中值的下标
 */
int med3(int[] x, int a, int b, int c) {
    return x[a] < x[b] ? // 第一次比较
        (x[b] < a[c] ? b : x[a] < x[c] ? c : a) : // 最多两次比较，最少一次比较
        (x[a] < a[c] ? a : x[b] < x[c] ? c : b); // 同上
}
```
Tukey提出了一种9数取中值的方法：连续运用3次`med3`得到3个中值下标，再对这三个中值下标运用`med3`得到最终的枢纽元位置。在这种方法中最多需要12次比较，最少需要8次比较，对于较大的数组而言，这些开销在整个排序过程中是很小的，而对于小数组来说则比较大。最终的枢纽元选择算法如下：
```java
/**
 * 枢纽元选择算法
 * @param off 待排序数组的起始下标
 * @param len 待排序元素个数
 * @return 枢纽元的位置
 */
int selectPivot(int[] x, int off, int len) {
    int m = off + (len >> 1); // 小数组使用中间位置作为枢纽元
    // 元素个数小于等于7的数组算是小数组
    if (len > 7) {
        int l = off;
        int r = off + len - 1; // 待排序截止位置
        // 元素个数大于40的算大数组，使用9中值法，否则使用3中值法
        if (len > 40) {
            /**
             * 在待排序列中找9个点，s = len / 8, 下面分割方法使得9个点的下标递增
             * -----------------------------------------------------------------
             * |l|...|l+s|...|l+2s|...|m-s|...|m|...|m+s|...|r-2s|...|r-s|...|r|
             * -----------------------------------------------------------------
             */
            int s = len / 8;
            l = med3(x, l, l+s, l+2*s);
            m = med3(x, m, m-s, m+s);
            r = med3(x, r-2*s, r-s, r);
        }
        m = med3(x, l, m, r);
    }
    return m;
}
```
### 相等元素的处理
论文中实现了类似经典快排算法，在大部分情况下比Unix 7th qsort快了大约12%, 但是在长度为100，000，序列中只包含0和1的数组中，比Unix 7th qsort慢了8倍。这是由于算法中会交换相等元素导致的，在数组包含大量重元素的情况下，__快速排序的递归性会使元素全部重复的子数组出现较多次__, 这里有巨大的优化空间。

经典快排的思路是一趟遍历中把数组划分中如下三部分：
```java
-------------------------------------
|      <=     |pivot|      >=       |
-------------------------------------
```
对于包含重复元素的情况，一个简单的想法是把数组划分成如下三部分：
```java
-----------------------------------------
|      <=     |   ==   |       >=       |
-----------------------------------------
```
这样的一个__好处: 中间相等的元素不用再参与递归计算，这会节省很多时间__. Dijkstra的“三向切分快排”实现了上面的思想，但是它有过多的交换，论文提出了一种更加巧妙的方法，__在排序过程中把相等元素分别移动到数组左端和右端__：
```java
------------------------------------------
|   ==   |   <   |   ?   |   >    |  ==  |
------------------------------------------
          ^       ^     ^        ^
          |       |     |        |
          a       b     c        d
a: 指向第一个小于pivot的元素，它之前的位置全是等于枢纽元的元素
b: 左侧待排序元素
c: 右侧待排序元素
d: 指向第一个大于pivot的元素，它之后的位置全市等于枢纽元的元素
```
一趟划分之后，得到如下的结果：
```java
------------------------------------------
|   ==   |     <       |     >    |  ==  |
------------------------------------------
          ^           ^ ^        ^
          |           | |        |
          a           c b        d
a: 指向第一个小于pivot的元素，它之前的位置全是等于枢纽元的元素
b: 指向第一个大于pivot的元素
c: 指向最后一个小于pivot的元素
d: 指向最后一个大于pivot的元素

数组的起始位置为l, 终止下标为r
a-l: 左侧等于pivot元素个数
b-a: 小于pivot元素个数
d-c: 大于pivot元素个数
r-d: 右侧等于pivot元素个数

```
下一步，把两端`==`的元素拷贝到中间，得到如下形式：
```java
------------------------------------------
|      <      |     ==      |      >     |
------------------------------------------
```
中间等于pivot的元素已经处在正确的位置，之后只需要递归调用左侧小于和右侧大于部分。这一部分的代码如下：
```java
// 调用上面的selectPivot得到m
int pivot = x[m];
// off: 起始位置; len: 待排序元素个数
int n = off + len;
int a = off, b = a, c = n - 1, d = c;
whiel(true) {
    // 注意 b<=c 防止越界
    while (b <= c && x[b] <= pivot) {
        // a的左边全都是等于pivot的，新的等于pivot元素放到a处，a往前移
        if (x[b] == pivot) {
            swap(x, b, a++);
        }
        b++;
    }

    while (c >= b && x[b] >= pivot) {
        // d的右边全是等于pivot的，新的等于Pivot元素放到d处，d往后移
        if (x[c] == pivot) {
            swap;(x, c, d--)
        }
        c--;
    }
    if (b > c) {
        break;
    }
    swap(x, b++, c--);
} 
// 把两端等于pivot的元素拷贝到中间
// a-off是左侧等于pivot的个数，b-a是小于的个数，我们只需要拷贝一个较小的部分
int s = min(a-off, b-a);
int i = 0;
while (i < s) {
    swap(x, off + i, b -i);
    i++;
}

// n-d-1右侧等于pivot的个数，d-c大于的个数
s = min(n-d-1, d-c);
i = 0;
while (i < s) {
    swap(x, b+i, n-1-i);
    i++;
}

// 递归调用左侧和右侧 
qsort(x, off, b-a);
qsort(x, n-(d-c), d-c)
```
把以上几部分拼起来就是完整的代码，这里把使用插入排序的最大个数定义成了6。

# 3. Dual-Pivot QuickSort
2009年提出的新的改进方法，也是目前Jdk中使用的，冷静一下，之后再来学习。