## 1. GC算法
#### 1. 引用计数法
缺点是无法解决循环依赖，且性能不高。
#### 2. 标记-清除
第一步先标记哪些对象是不可达的；第二步清理不可达对象。

缺点：内存碎片
#### 3. 标记-清除-整理
在标记-清除的基础上，再进行内存整理。

好处是：无内存碎片；缺点：进行了一次内存整理

#### 4. 复制算法
把内存一分为二，运行时只在其中一半分配; 垃圾回收时，把可达的对象移动到另一半，这一半就可以整个清空。

优点：速度快，无碎片； 缺点： 浪费了一半空间。

不过JVM改进了这个算法，它把整个新生代分成:eden, from, to，假设当前from是可以分配的。在进行分配的时候，从eden和from申请内存；当进行垃圾回收时，把eden和from中存活的对象移动到to中，然后eden和from就可以清空了。这里有一点需要注意：如果to的空间不足以装下存活对象，还有老年代呢。这种方式适合垃圾较多，存活对象较少的情况，有研究指出：新生代90%的对象都是朝生夕死的。

#### 5. 分代算法
没有一种算法足够优秀，可以一统天下。因此jvm采用了分代的垃圾收集算法：
```java
+----------+-------------+
|  新生代   |   复制算法   |
+----------+-------------+
|  老年代   | 标记清除/压缩 |
+----------+-------------+
```