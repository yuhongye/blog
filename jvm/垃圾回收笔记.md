# 垃圾回收算法手册：自动内存管理的艺术 笔记

## 第1章 概述

##### 1.   mutator: 执行应用代码，可以理解成是我们的应用程序

##### 2. collector：找到不可达对象并将其回收

##### 3. allocator: 支持两种操作allocate和free，功能上和collector正交

##### 4. 存活性、正确性和可达性

​	__可达性__: 从跟集合出发，最终可以遍历到该对象，则称对该对象是可达的

​	__存活性__：如果某一对象在后续的执行中可能会被访问，则称该对象是存活的。存活性是一个不确定的特征，因为无法预测后续是否会访问某个对象，所以一般用可达性来近似存活性。

​	__正确性__: 对collector而言永远不会回收一个存活的对象，实际近似成不会回收一个可达的对象

##### 5. 显式内存管理 vs 自动内存管理

"存活性是一个全局特征，调用free函数将对象释放却是局部行为。"，所以如何将对象正确地释放是一个十分复杂的问题：

* 在显式内存管理中，无法在局部上下文长掌握全局信息，因此会带来悬挂指针、二次释放、内存泄露等问题
* 在自动内存管理中，collector掌握堆中对象的全局信息以及所有可能访问堆中对象的线程因此，因此可以决定任意对象是否回收

原则上讲，collector最终会回收所有不可能对象，有两个注意事项：

1. Tracing collection(追踪式回收，什么是追踪式回收?)引入了"垃圾"这一具有明确判定标准的概念，但是"垃圾"不一定包含所有不再使用的对象，有些对象可达，但是程序永远都不再使用了
2. 处于效率原因，某些对象可能不会被回收。

##### 6. collector关注的特征

​	__安全性__：任何时候不能回收存活对象

​	__吞吐量__: 一般使用collector与mutator活跃度的比值来表示

​	__完整性和及时性__：我觉得这两个不重要，collector的目的是为了更好的分配内存，那至于是不是要在一次垃圾回收中回收全部的垃圾和什么时候回收某些垃圾根本不重要。在并发垃圾回收器中，mutator和collector并发的运行，其目的在于减少用户程序停顿时间，这类collector会遇到floating garbage，即某些对象在回收过程启动后才变成垃圾，那么该对象只有在下次回收周期才会得到回收。

​	__停顿时间__：不论如何，缩短停顿时间的措施通常会增大整体处理时间

​	__空间开销__：内存管理的目的是安全且高效的使用内存空间，但是collector会产生一定程度的space overhead，这个也需要关注。

​	__可扩展性__: 随着单机的并行度提高，collector能不能利用这些多核的硬件。